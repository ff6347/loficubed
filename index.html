<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotating Cubes</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

```
    #canvas-container {
        width: 100vw;
        height: 100vh;
    }
    
    #controls {
        position: absolute;
        top: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.7);
        padding: 15px;
        border: 1px solid #333;
        color: #fff;
        font-size: 11px;
        min-width: 180px;
    }
    
    .control-group {
        margin-bottom: 12px;
    }
    
    .control-group:last-child {
        margin-bottom: 0;
    }
    
    label {
        display: block;
        margin-bottom: 4px;
        text-transform: uppercase;
        font-size: 10px;
        color: #888;
    }
    
    input[type="range"] {
        width: 100%;
        height: 2px;
        background: #333;
        outline: none;
        -webkit-appearance: none;
    }
    
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 10px;
        height: 10px;
        background: #fff;
        cursor: pointer;
        border-radius: 0;
    }
    
    input[type="range"]::-moz-range-thumb {
        width: 10px;
        height: 10px;
        background: #fff;
        cursor: pointer;
        border-radius: 0;
        border: none;
    }
    
    .value {
        display: inline-block;
        float: right;
        color: #fff;
        font-size: 11px;
    }
</style>
```

</head>
<body>
    <div id="canvas-container"></div>

```
<div id="controls">
    <div class="control-group">
        <label>rotation speed <span class="value" id="rotSpeed-value">1.0</span></label>
        <input type="range" id="rotSpeed" min="0" max="3" step="0.1" value="1.0">
    </div>
    
    <div class="control-group">
        <label>size scale <span class="value" id="sizeScale-value">1.0</span></label>
        <input type="range" id="sizeScale" min="0.3" max="2" step="0.1" value="1.0">
    </div>
    
    <div class="control-group">
        <label>cube count <span class="value" id="cubeCount-value">8</span></label>
        <input type="range" id="cubeCount" min="3" max="15" step="1" value="8">
    </div>
    
    <div class="control-group">
        <label>spacing <span class="value" id="spacing-value">1.0</span></label>
        <input type="range" id="spacing" min="0.5" max="2.0" step="0.1" value="1.0">
    </div>
    
    <div class="control-group">
        <label>color steps <span class="value" id="colorSteps-value">8</span></label>
        <input type="range" id="colorSteps" min="2" max="32" step="1" value="8">
    </div>
    
    <div class="control-group">
        <label>resolution <span class="value" id="pixelRatio-value">0.25</span></label>
        <input type="range" id="pixelRatio" min="0.1" max="1.0" step="0.05" value="0.25">
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    
    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
    );
    camera.position.z = 15;
    
    const renderer = new THREE.WebGLRenderer({ 
        antialias: false,
        precision: 'lowp'
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.imageRendering = 'pixelated';
    renderer.domElement.style.imageRendering = 'crisp-edges';
    document.getElementById('canvas-container').appendChild(renderer.domElement);
    
    // Low-res render target for degraded look
    const pixelRatio = 0.25; // Render at 1/4 resolution
    const renderTarget = new THREE.WebGLRenderTarget(
        window.innerWidth * pixelRatio,
        window.innerHeight * pixelRatio,
        {
            minFilter: THREE.NearestFilter,
            magFilter: THREE.NearestFilter,
            format: THREE.RGBFormat
        }
    );
    
    // Post-processing scene
    const postScene = new THREE.Scene();
    const postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    
    const postMaterial = new THREE.ShaderMaterial({
        uniforms: {
            tDiffuse: { value: renderTarget.texture },
            colorSteps: { value: 8.0 },
            ditherAmount: { value: 0.03 }
        },
        vertexShader: `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform sampler2D tDiffuse;
            uniform float colorSteps;
            uniform float ditherAmount;
            varying vec2 vUv;
            
            float dither(vec2 uv) {
                float noise = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);
                return noise * ditherAmount;
            }
            
            void main() {
                // Chromatic aberration
                vec2 offset = vec2(0.002, 0.0);
                float r = texture2D(tDiffuse, vUv + offset).r;
                float g = texture2D(tDiffuse, vUv).g;
                float b = texture2D(tDiffuse, vUv - offset).b;
                vec4 color = vec4(r, g, b, 1.0);
                
                // Add dithering
                float d = dither(gl_FragCoord.xy);
                color.rgb += d;
                
                // Color banding/posterization (JPEG-like)
                color.rgb = floor(color.rgb * colorSteps + 0.5) / colorSteps;
                
                // Block compression artifacts (8x8 JPEG blocks)
                vec2 blockSize = vec2(8.0);
                vec2 block = floor(gl_FragCoord.xy / blockSize);
                float blockNoise = fract(sin(dot(block, vec2(12.9898, 78.233))) * 43758.5453);
                color.rgb += (blockNoise - 0.5) * 0.015;
                
                // Scanline-like banding
                float scanline = mod(gl_FragCoord.y, 4.0) / 4.0;
                color.rgb *= 0.95 + scanline * 0.05;
                
                gl_FragColor = color;
            }
        `
    });
    
    const postPlane = new THREE.PlaneGeometry(2, 2);
    const postQuad = new THREE.Mesh(postPlane, postMaterial);
    postScene.add(postQuad);
    
    // Parameters
    let params = {
        rotSpeed: 1.0,
        sizeScale: 1.0,
        cubeCount: 8,
        spacing: 1.0,
        colorSteps: 8.0,
        pixelRatio: 0.25
    };
    
    // Create cubes array
    let cubes = [];
    
    function createCubes() {
        // Clear existing cubes
        cubes.forEach(cube => scene.remove(cube));
        cubes = [];
        
        // Create new cubes
        for (let i = 0; i < params.cubeCount; i++) {
            const size = (i + 1) * params.spacing * params.sizeScale;
            const geometry = new THREE.BoxGeometry(size, size, size);
            const edges = new THREE.EdgesGeometry(geometry);
            const material = new THREE.LineBasicMaterial({ 
                color: 0xffffff,
                linewidth: 2
            });
            const cube = new THREE.LineSegments(edges, material);
            
            // All cubes centered at origin, nested
            cube.position.x = 0;
            cube.position.y = 0;
            cube.position.z = 0;
            
            // Store initial rotation offset
            cube.userData.rotationOffset = i * 0.3;
            cube.userData.index = i;
            
            scene.add(cube);
            cubes.push(cube);
        }
    }
    
    createCubes();
    
    // Animation
    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.001;
        
        cubes.forEach((cube, index) => {
            const speed = (index + 1) * 0.15 * params.rotSpeed;
            const offset = cube.userData.rotationOffset;
            
            // Different rotation patterns for each cube
            cube.rotation.x = time * speed * 0.8 + offset;
            cube.rotation.y = time * speed + offset * 0.5;
            cube.rotation.z = time * speed * 0.3 + offset * 0.7;
        });
        
        // Render to low-res target
        renderer.setRenderTarget(renderTarget);
        renderer.render(scene, camera);
        
        // Render post-processed result to screen
        renderer.setRenderTarget(null);
        renderer.render(postScene, postCamera);
    }
    
    animate();
    
    // Controls
    function updateControl(id, param) {
        const slider = document.getElementById(id);
        const valueDisplay = document.getElementById(`${id}-value`);
        
        slider.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            params[param] = value;
            const precision = (param === 'cubeCount') ? 0 : 1;
            valueDisplay.textContent = value.toFixed(precision);
            
            if (param === 'cubeCount' || param === 'sizeScale' || param === 'spacing') {
                createCubes();
            }
        });
    }
    
    updateControl('rotSpeed', 'rotSpeed');
    updateControl('sizeScale', 'sizeScale');
    updateControl('cubeCount', 'cubeCount');
    updateControl('spacing', 'spacing');
    
    // Special handlers for post-processing params
    document.getElementById('colorSteps').addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        params.colorSteps = value;
        postMaterial.uniforms.colorSteps.value = value;
        document.getElementById('colorSteps-value').textContent = value.toFixed(0);
    });
    
    document.getElementById('pixelRatio').addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        params.pixelRatio = value;
        document.getElementById('pixelRatio-value').textContent = value.toFixed(2);
        renderTarget.setSize(
            window.innerWidth * value,
            window.innerHeight * value
        );
    });
    
    // Handle window resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderTarget.setSize(
            window.innerWidth * params.pixelRatio,
            window.innerHeight * params.pixelRatio
        );
    });
</script>
```

</body>
</html>
